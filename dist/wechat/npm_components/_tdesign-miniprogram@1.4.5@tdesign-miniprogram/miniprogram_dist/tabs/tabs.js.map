{"version":3,"file":"npm_components/_tdesign-miniprogram@1.4.5@tdesign-miniprogram/miniprogram_dist/tabs/tabs.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///../node_modules/_tdesign-miniprogram@1.4.5@tdesign-miniprogram/miniprogram_dist/tabs/tabs.js"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SuperComponent, wxComponent } from '../common/src/index';\nimport props from './props';\nimport config from '../common/config';\nimport touch from '../mixins/touch';\nimport { getRect, uniqueFactory } from '../common/utils';\nconst { prefix } = config;\nconst name = `${prefix}-tabs`;\nconst getUniqueID = uniqueFactory('tabs');\nlet Tabs = class Tabs extends SuperComponent {\n    constructor() {\n        super(...arguments);\n        this.options = {\n            pureDataPattern: /^currentLabels$/,\n        };\n        this.behaviors = [touch];\n        this.externalClasses = [\n            `${prefix}-class`,\n            `${prefix}-class-item`,\n            `${prefix}-class-active`,\n            `${prefix}-class-track`,\n            `${prefix}-class-content`,\n        ];\n        this.relations = {\n            '../tab-panel/tab-panel': {\n                type: 'descendant',\n                linked(target) {\n                    this.children.push(target);\n                    this.initChildId();\n                    target.index = this.children.length - 1;\n                    this.updateTabs();\n                },\n                unlinked(target) {\n                    this.children = this.children.filter((item) => item.index !== target.index);\n                    this.updateTabs(() => this.setTrack());\n                    this.initChildId();\n                },\n            },\n        };\n        this.properties = props;\n        this.controlledProps = [\n            {\n                key: 'value',\n                event: 'change',\n            },\n        ];\n        this.observers = {\n            value(name) {\n                if (name !== this.getCurrentName()) {\n                    this.setCurrentIndexByName(name);\n                }\n            },\n        };\n        this.data = {\n            prefix,\n            classPrefix: name,\n            tabs: [],\n            currentLabels: [],\n            currentIndex: -1,\n            trackStyle: '',\n            offset: 0,\n            scrollLeft: 0,\n            tabID: '',\n            placement: 'top',\n        };\n        this.lifetimes = {\n            created() {\n                this.children = this.children || [];\n            },\n            attached() {\n                wx.nextTick(() => {\n                    this.setTrack();\n                });\n                getRect(this, `.${name}`).then((rect) => {\n                    this.containerWidth = rect.width;\n                });\n                this.setData({\n                    tabID: getUniqueID(),\n                });\n            },\n        };\n        this.methods = {\n            onScroll(e) {\n                const { scrollLeft } = e.detail;\n                this.setData({\n                    scrollLeft,\n                });\n            },\n            updateTabs(cb) {\n                const { children } = this;\n                const tabs = children.map((child) => child.data);\n                tabs.forEach((item) => {\n                    if (typeof item.icon === 'string') {\n                        item.icon = { name: item.icon };\n                    }\n                });\n                this.setData({ tabs }, cb);\n                this.setCurrentIndexByName(this.properties.value);\n            },\n            setCurrentIndexByName(name) {\n                const { children } = this;\n                const index = children.findIndex((child) => child.getComputedName() === `${name}`);\n                if (index > -1) {\n                    this.setCurrentIndex(index);\n                }\n            },\n            setCurrentIndex(index) {\n                if (index <= -1 || index >= this.children.length)\n                    return;\n                const Labels = [];\n                this.children.forEach((child, idx) => {\n                    const isActive = index === idx;\n                    if (isActive !== child.data.active) {\n                        child.render(isActive, this);\n                    }\n                    Labels.push(child.data.label);\n                });\n                const { currentIndex, currentLabels } = this.data;\n                if (currentIndex === index && currentLabels.join('') === Labels.join(''))\n                    return;\n                this.setData({\n                    currentIndex: index,\n                    currentLabels: Labels,\n                }, () => {\n                    this.setTrack();\n                });\n            },\n            getCurrentName() {\n                if (this.children) {\n                    const activeTab = this.children[this.data.currentIndex];\n                    if (activeTab) {\n                        return activeTab.getComputedName();\n                    }\n                }\n            },\n            calcScrollOffset(containerWidth, targetLeft, targetWidth, offset) {\n                return offset + targetLeft - (1 / 2) * containerWidth + targetWidth / 2;\n            },\n            getTrackSize() {\n                return new Promise((resolve, reject) => {\n                    if (this.trackWidth) {\n                        resolve(this.trackWidth);\n                        return;\n                    }\n                    getRect(this, `.${prefix}-tabs__track`)\n                        .then((res) => {\n                        if (res) {\n                            this.trackWidth = res.width;\n                            resolve(this.trackWidth);\n                        }\n                    })\n                        .catch(reject);\n                });\n            },\n            setTrack() {\n                return __awaiter(this, void 0, void 0, function* () {\n                    const { children } = this;\n                    if (!children)\n                        return;\n                    const { currentIndex } = this.data;\n                    if (currentIndex <= -1)\n                        return;\n                    try {\n                        const res = yield getRect(this, `.${prefix}-tabs__item`, true);\n                        const rect = res[currentIndex];\n                        if (!rect)\n                            return;\n                        let count = 0;\n                        let distance = 0;\n                        let totalSize = 0;\n                        res.forEach((item) => {\n                            if (count < currentIndex) {\n                                distance += item.width;\n                                count += 1;\n                            }\n                            totalSize += item.width;\n                        });\n                        if (this.containerWidth) {\n                            const offset = this.calcScrollOffset(this.containerWidth, rect.left, rect.width, this.data.scrollLeft);\n                            const maxOffset = totalSize - this.containerWidth;\n                            this.setData({\n                                offset: Math.min(Math.max(offset, 0), maxOffset),\n                            });\n                        }\n                        if (this.data.theme === 'line') {\n                            const trackLineWidth = yield this.getTrackSize();\n                            distance += (rect.width - trackLineWidth) / 2;\n                        }\n                        this.setData({\n                            trackStyle: `-webkit-transform: translateX(${distance}px);\n            transform: translateX(${distance}px);\n          `,\n                        });\n                    }\n                    catch (err) {\n                        this.triggerEvent('error', err);\n                    }\n                });\n            },\n            onTabTap(event) {\n                const { index } = event.currentTarget.dataset;\n                this.changeIndex(index);\n            },\n            onTouchStart(event) {\n                if (!this.properties.swipeable)\n                    return;\n                this.touchStart(event);\n            },\n            onTouchMove(event) {\n                if (!this.properties.swipeable)\n                    return;\n                this.touchMove(event);\n            },\n            onTouchEnd() {\n                if (!this.properties.swipeable)\n                    return;\n                const { direction, deltaX, offsetX } = this;\n                const minSwipeDistance = 50;\n                if (direction === 'horizontal' && offsetX >= minSwipeDistance) {\n                    const index = this.getAvailableTabIndex(deltaX);\n                    if (index !== -1) {\n                        this.changeIndex(index);\n                    }\n                }\n            },\n            onTouchScroll(event) {\n                this._trigger('scroll', event.detail);\n            },\n            changeIndex(index) {\n                const currentTab = this.data.tabs[index];\n                const { value, label } = currentTab;\n                if (!(currentTab === null || currentTab === void 0 ? void 0 : currentTab.disabled) && index !== this.data.currentIndex) {\n                    this._trigger('change', { value, label });\n                }\n                this._trigger('click', { value, label });\n            },\n            getAvailableTabIndex(deltaX) {\n                const step = deltaX > 0 ? -1 : 1;\n                const { currentIndex, tabs } = this.data;\n                const len = tabs.length;\n                for (let i = step; currentIndex + step >= 0 && currentIndex + step < len; i += step) {\n                    const newIndex = currentIndex + i;\n                    if (newIndex >= 0 && newIndex < len && tabs[newIndex]) {\n                        if (!tabs[newIndex].disabled) {\n                            return newIndex;\n                        }\n                    }\n                    else {\n                        return currentIndex;\n                    }\n                }\n                return -1;\n            },\n        };\n    }\n    initChildId() {\n        this.children.forEach((item, index) => {\n            item.setId(`${this.data.tabID}_panel_${index}`);\n        });\n    }\n};\nTabs = __decorate([\n    wxComponent()\n], Tabs);\nexport default Tabs;\n"],"names":[],"sourceRoot":""}